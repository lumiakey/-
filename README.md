# shortLink
应西瓜创客招聘要求 完成的短网址服务

# 问题分析
网址映射会涉及到大量数据，互联网上的网站多达几十亿，算上子网页就更是天文数字。如何存下这样的海量数据，如何对这样的海量数据中的每一个长链接生成一个短链接是我考虑的第一个问题，如何快速生成不重复的短链接再返回给用户尤为重要。其次，网址映射的实现无非就是服务器重定向，但是如何快速根据短链接找到长链接更是一个优化需要考虑的问题。

# 如何生成短链接
定义char[] deful = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e',
            'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
用Java APi随机生成0-61的数deful下标 将得到0-Z共62种可能性，也就是62进制。
我将默认短链接定义为8位，第一位表示短链接类型，62的7次方已经是天文数字，至于为什么有短链接类型下面说。


# 如何解决生成时耗时等待
系统启动的时候启动线程生成不同类型的短链接放到队列中，用户有生成需求的时候直接从消息队列中返回。生成短链接和取短链接用生产者消费者模式实现，为保证高并发可靠，使用阻塞消息队列。

# 如何解决查询和存储问题
如果把所有数据放到一张表里，不仅存储不合理，查询效率底下，设计上也不合理。临时的短链接可以可以用线程去扫描特定的表，过期的表数据予以删除。所以我选择对数据库分表，将数据库划分为三个类型临时短链接表(Temporary)，自定义短链接表(Custom),持久型短链接表(Persistent)，每种类型的表分为从“0-9a-zA-Z”62个表。这样查询效率会提高很多，也为后面清理数据带来方便。

尽管如此，对数据库操作依然需要IO耗时任务，为了进一步优化，首次短链接跳转长链接后会将短链接对应的长链接写到redis中，下一次访问将会直接从内存中取出，避免对库操作。

# 总结
考虑到网址映射的高并发低延时情况，会频繁对数据库进行查找操作
主要从生成短网址和短网址映射长网址两个方向优化：
  
  生成短网址：
  后端将短网址按照不同类型生成20个放在队列中，请求获取短网址的时候可以直接从队列中取出，新建一个线程完成落库。
  
  映射长网址：
  映射的时候先去Redis中读，如果没有就去查库，查库后写到redis里，第二次请求直接从redis中返回，新建一个线程完成访问次数+1操作。
  
  库设计：
  数据库按照不同类型分成最多186个表。非永久短链接可以用一个线程去扫描非永久表完成数据清理。
  
